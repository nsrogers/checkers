\documentclass[12pt]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{hyperref}
\lstset{basicstyle=\footnotesize, numbers=left}
\begin{document}

\begin{titlepage}
\title{\huge \bf Checkers with AI}
\date{\today}
\author{Thomas White \\
    \and Nathan Rogers \\
    \and Daniel Shubin}
\maketitle
\begin{center}
    CMPS 112 - Comparative Programming Languages \\
    Final Project Report
\end{center}
\end{titlepage}

\section{Introduction:}
    \subsection{Overview:}
        Our project was to create a checkers engine in Python,
        that is playable by two AI's and humans. The two AI's
        were written in C++ and Haskell.
    \subsection{Why we chose C++, Haskell, and Python:}
        We chose Python as the front end implementation language
        because Python allows you to easily interface with other
        languages. Python is also a scripting language.
        It is also a language that we knew and could efficiently
        implement the checkers engine.
        For our first AI, we chose C++ since our team has a lot of
        experience with the language, and is a good contrast to functional
        programming since it is purely imperative.
        For our second AI, we chose Haskell because we had experience from
        the class. And it is a contrast to the imperative languages since
        it is purely functional.

\section{Algorithms}
		
	\subsection{Move Validation}
	Move validation was the bulk of our ugly code as the best way of implementing was to hardcode all the conditions that had to be met and matching them. We separated the move validation and application to simply the latter as applying moves was complicated enough in haskell.
	
	\subsection{Flipping the board}
Early on we decided to simplify the AI's code by always giving the AI the game state as if they were the player sitting at the top of the board. This was accomplished by flipping before the AI was called on the bottom player.		The flipping code had to be implemented in the AI's as well because the MinMax algorithm requires playing as the other player every other depth
	
	\subsection{MinMax}
The MinMax algorithm consists of finding every possible board position after a set number of moves. Then Generating a score for the boards final position. The board was stored in a tree with each node storing a move, a score, and having a list of children nodes. The tree is generated by recursively calling the function for each possible move with a depth of one less the previous and a version of the board with the move applied and then this board is flipped to simulate the other players turn. The building part recurses until it reaches the maximum depth specified and calculates and saves the heuristic in the leaf node. The function return on leaf node and all the nodes are added to the list in a depth first fashion. After the tree is built it it traversed depth first again but this time will traverse all the way to the bottom non-leaf nodes and find the maximum or minimum heuristic for the node depending on whether it simulated your turn or the opponent. The calls keep returning the max or min until the best value is which ever node has the highest value at the end.
	
	\subsection{Heuristic}
Our heuristic was chosen due to its simplicity and ease in debugging its decisions. We simply added the pieces on the board with the opponents pieces being negative to the score and your pieces being positive. When summing the regular pieces were worth 1 and kings are worth 2. We also added code to detect a stalemate and made it a maximum value when the opponent cant move and a minimum amount when you cant move since this is a loss for the player that can't win. 

	\subsection{Language Specific Deviations}
C++ was the first language we decided to implement and it stuck closest to the design. When we made modifications we changed the design. The calling of C++ code in python with C types made it so we had to insert the move output stored in the STL list type of C++ into a C array so python could read it.
\par
Haskells lack of for loops made the code look different but overall we simply used a map our function over the sequence [0:31] to simulate indexes into arrays. The part of the algorithm that preformed MinMax traversal of the tree was much more complicated due to Haskells lack of states so the algorithm to finds the extreme of the row required a self recursive call as well as a downward depth recursive call and a comparison of all the return values of the depth call. This compares to the C++ code where we only had to recourse downwards and compare the results to a variable stored outside the for loop.
\par
Python only needed the Validate move to checks the moves inputted. The python code for validation move was basically the same as C as it turn out the best method was just a bunch of if statements checking conditions for each movement. To check for stale make all possible a list of all feasible 1 space moves or single jumps was generated and if any passed validating there was no stalemate.

\section{Calling C++ and Haskell From Python}
    \subsection{C++}
        \subsubsection{Introduction}
            Python has a built in module called ctypes which allows the programmer
            to use C types. These are literally variables that are of the same types
            one would use in a C program. This module also allows one to load in compiled
            library files and call functions in that library. The return values from these
            functions are C types as well and things like Python Lists or Dictionaries must
            be converted into C types before being used in the python program. In our project
            we wrote an AI in C++ which is called from our main Python program. We pass in
            the board and also a pointer to a list of moves to be returned, more on this
            later.
        \subsubsection{Code Example}
            \lstinputlisting[language=Python, firstline=8, lastline=22]{../checkers.py}
        \subsubsection{How the code works}
            First we convert our board, which is a list of ints in python, to a C style array
            of ints. On lines 3 and 4, we initialize another C array of ints which will eventually
            be the returned move. On lines 5 and 6 we load a function from our precompiled library
            and tell ctypes explicitly what the return type is going to be. We then call the function
            passing in the board and the pointer to our move array. When we return from the function,
            we must convert the C style array of ints into a Python list (lines 8-14). And finally
            we return the AI's move.
        \subsubsection{Why we chose this}
            The foreign function interface ctypes is very well documented and easy to use.
            It gives the programmer the capabilities (speed) of C/C++ programming
            and still have the higher level Python features in the main code. Since ctypes
            is included in Python out of the box, no additional work needs to be done to prepare
            the C/C++ code to work. Simply compile the code into a shared library and import that
            library with ctypes. Since python has some amount of features from the functional
            programming side of things, the programmer can load a C/C++ function in and treat it
            as first class. First class functions can be passed around just like regular variables.
            In the sample code above, we load the function and set it as a variable. Then call that
            function, using the variable. ctypes encapsulates the actual function call and return
            values, allowing us to access and change metadata about the function. We can tell ctypes
            what the return type of the function is and access the contents of the return value after
            the function is called. This allows for better readability in the Python code and
            generally smooths the relationship between Python and C/C++
            
    \subsection{Haskell}
        \subsubsection{Introduction}
            Unlike C/C++, Python doesn't have built in compatibility with Haskell. Haskell however
            does have a foreign function interface built in to the language and the Glasgow Haskell
            Compiler. There is a number of libraries out there which deal with the Haskell FFI and
            allow easy interfacing with other languages. One such library is called HaPy, which
            provides an interface between Python and Haskell which allows Python to directly call
            Haskell functions, much like how ctypes works with C/C++.
        \subsubsection{Code Example}
            \lstinputlisting[language=Python, firstline=3, lastline=3,
                title=Importing from Python (checkers.py)]{../checkers.py}
            \lstinputlisting[language=Haskell,
                title=Exporting the AI module to HaPy (Export.hs)]{../Export.hs}
            \lstinputlisting[language=Haskell, firstline=1, lastline=7,
                title=First few lines of defining our AI module (HsklAI.hs)]{../HsklAI.hs}
        \subsubsection{How the code works}
            The code and installation instructions for HaPy can be
            found here: \\ \url{https://github.com/sakana/HaPy} \\
            Generally what this library does is that once you compile Haskell into a
            shared library (much like we do for C/C++) the Python types are converted into
            a C representation, and then into a Haskell representation, then the function is
            executed. The return type is propagated in reverse to Python 
            $(Haskell \rightarrow C \rightarrow Python)$.
            HaPy currently supports converting Python primitive types (int, string, etc.) 
            as well as lists into their equivalent in Haskell. Calling the function is also
            abstracted away nicely so that when the programmer wants to call a Haskell 
            function from Python, is looks exactly like a standard python library
            function call would.
            \lstinputlisting[language=Python, firstline=171, lastline=171]{../checkers.py}
        \subsubsection{Why we chose this}
            Using a library like HaPy to do the dirty work of using the Foreign Function Interface
            allowed us to focus more on writing good Haskell code. Instead of worrying about 
            the representation of our types and how they would propagate to Python, we just wrote
            our Haskell code and let the library take care of the type issues. Over all, HaPy is
            easy to set up (at least on the Mac system we primarily tested on) and has a clean
            and easy to use interface on the Python side. It requires a non trivial amount
            of set up to initially get everything to work, but HaPy has clear instructions
            on how to get project files set up. And once the libraries are installed in both
            Python and Haskell everything works beautifully. 
            %We could have used Sockets or stdin instead of the hooking the guctions into python but each require a lot more bookkeeping code and add there own complications.

\end{document}

















